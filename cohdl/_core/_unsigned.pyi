from __future__ import annotations

from ._bit_vector import BitVector
from ._integer import Integer

class Unsigned(BitVector):
    @staticmethod
    def upto(max_value: int) -> Unsigned: ...
    def __init__(
        self,
        val: None | BitVector | str | int = None,
    ): ...
    @classmethod
    def min(self) -> int: ...
    @classmethod
    def max(self) -> int: ...
    def __index__(self) -> int: ...
    def to_int(self) -> int: ...
    def add(self, rhs: Unsigned | int | Integer, target_width=None) -> Unsigned: ...
    def sub(self, rhs: Unsigned | int | Integer, target_width=None) -> Unsigned: ...
    def __add__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __radd__(self, lhs: int | Integer) -> Unsigned: ...
    def __sub__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __rsub__(self, lhs: int | Integer) -> Unsigned: ...
    def __mul__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __floordiv__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __mod__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __neg__(self) -> Unsigned: ...
    def __and__(self, other: Unsigned) -> Unsigned: ...
    def __or__(self, other: Unsigned) -> Unsigned: ...
    def __xor__(self, other: Unsigned) -> Unsigned: ...
    def __eq__(self, other: BitVector | int | Integer) -> bool: ...
    def __ne__(self, other: BitVector | int | Integer) -> bool: ...
    def __lt__(self, rhs: Unsigned | int | Integer) -> bool: ...
    def __gt__(self, rhs: Unsigned | int | Integer) -> bool: ...
    def __le__(self, rhs: Unsigned | int | Integer) -> bool: ...
    def __ge__(self, rhs: Unsigned | int | Integer) -> bool: ...
    def __lshift__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def __rshift__(self, rhs: Unsigned | int | Integer) -> Unsigned: ...
    def resize(
        self, target_width: int | None = None, *, zeros: int = 0
    ) -> Unsigned: ...
